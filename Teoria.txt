1. SINTAXIS Y TIPOS
    Go es un lenguaje estaticamente tipado y compilado, con sintaxis clara y concisa
   
    1.2 VARIABLES
       Declaracion explicita: var edad int = 30
                              var nombre string = "Juan"
       Inferencia de tipo (Go lo deduce): var activo = true // bool
                                          var temp = 36.6 // float64
       Declaracion corta (solo dentro de funciones): mensaje := "Hola mundo"
                                                     contador := 5
    1.3 TIPOS PRIMITIVOS
       Tipo        Descripcion          Ejemplo
       int       Entero            var x int = 42
       float64   Decimal           var pi float64 = 3.14
       string    Texto             var s string = "Hola"
       bool      Booleano          var ok bool = true
       rune      Caracter Unicode  var letra rune = 'a'
       byte      Alias de uint8    var b byte = 255
    
    1.4 CONSTANTES
        const pi = 3.14159
        const saludo string = "Hola"
    
    1.5 ARRAYS Y SLICES
        Array (tamaño fijo): var numeros [3]int = [3]int{1, 2, 3}
        Slices (lista dinamica): nombres := []string{"Ana", "Luis", "Pedro"}
        Operaciones con slices:
            nombres = append(nombres, "Laura") // agrega Laura a la lista de nombres
            fmt.Println(nombres[1]) // Luis
            fmt.Println(len(nombres)) // largo del slice
    
    1.6 MAPS (dicts/claves y valores)
        edades := map[string]int{
            "Juan": 30,
            "Ana": 25,
        }
        fmt.Println(edades["Juan"]) // 30

2. CONTROL DE FLUJO Y FUNCIONES

    2.1 ESTRUCTURAS DE CONTROL
        if, else if, else:
            edad := 20
            if edad < 18 {
                fmt.Println("Menor de edad")
            } else if edad < 65 {
                fmt.Println("Adulto")
            } else {
                fmt.Println("Jubilado")
            }
        
        switch: mas limpio que muchos if
            dia := "martes"

            switch dia {
                case "lunes":
                    fmt.Println("Comienza la semana")
                case "viernes":
                    fmt.Println("Casi finde!")
                default:
                    fmt.Println("Dia normal")
            }
        
                sin condicion
            valor := 10
            switch {
                case valor < 0:
                    fmt.Println("Negativo")
                case valor == 0:
                    fmt.Println("Cero")
                default:
                    fmt.Println("Positivo")
            }
        
        for: Go solo tiene for como bucle (no hay while, do-while)

            Clasico:
                for i := 0; i < 5; i++ {
                    fmt.Println(i)
                }
            
            Tipo while:
                x := 0
                for x < 3 {
                    fmt.Println(x)
                    x++
                }
            
            For infinito:
                for {
                    fmt.Println("Esto corre para siempre")
                    break // Salis manualmente
                }
        
        break y continue:
            for i := 0; i < 5; i++ {
                if i == 2 {
                    continue // salta al siguiente
                }
                if i == 4 {
                    break // corta el bucle
                }
                fmt.Println(i)
            } // imprime 0 1 3
    
    2.2 FUNCIONES
        Declaracion:
            func saludar(nombre string) {
                fmt.Println("Hola", nombre)
            }
        
        Llamado:
            saludar("Mara")
        
        Con retorno:
            func cuadrado(n int) int {
                return n*n
            }

            resultado := cuadrado(4) // 16

        Multiples retornos:
            func dividir(dividendo, divisor float64) (float64, bool) {
                if divisor == 0 {
                    return 0, false
                }
                return dividendo / divisor, true
            }
        
        Funciones anonimas (sin nombre):
            suma := func(a, b int) int {
                return a+b
            }
            fmt.Println(suma(2, 3)) // 5
        
        Closures (recuerdan su contexto):
            func contador() func() int {
                x := 0
                return func() int {
                    x++
                    return x
                }
            }

            c := contador()
            fmt.Println(c()) // 1
            fmt.Println(c()) // 2

3. STRUCTS Y METODOS
    En Go no hay clases ni objetos como en Java o Python, pero si hay structs y metodos,
    que permiten encapsular datos y comportamiento de forma muy poderosa

    3.1 STRUCT
        Es un conjunto de campos nombrados que agrupan datos relacionados, parecido a una "clase" en otros lenguajes
            Definicion:
                type Persona struct { // define un nuevo tipo Persona
                    Nombre string
                    Edad int
                    Activo bool // cada campo tiene su propio tipo
                }

            Crear y usar instancias:
                p1 := Persona {
                    Nombre: "Ana",
                    Edad: 36,
                    Activo: true,
                }

                p2 := Persona{"Luis", 25, false}

                fmt.Println(p1.Nombre)
                p2.Edad = 26

            Metodos asociados:
                Metodo con receptor por valor:
                    func (p Persona) Saludar() { // trabaja con copia de p
                        fmt.Printf("Hola, soy %s y tengo %d años\n", p.Nombre, p.Edad)
                    }

                Metodo con receptor por puntero:
                    func (p *Persona) CumplirAnios() {
                        p.Edad++ // modifica la instancia original
                    }

            Composicion en lugar de herencia:
                Go no tiene herencia de clases, pero puedes componer structs incluyendo uno dentro de otro
                    type Direccion struct {
                        Calle string
                        Ciudad string
                    }

                    type Empleado struct {
                        Persona      // embedding: todos los campos y metodos de Persona
                        ID     string
                        Direccion    // embedding anidado
                    }

                    e := Empleado {
                        Persona: Persona {Nombre: "Mara", Edad: 28, Activo: true},
                        ID: "EMP001",
                        Direccion: Direccion {Calle: "Av. Siempreviva", Ciudad: "Springfield"},
                    }
                    fmt.Println(e.Nombre) // Mara
                    fmt.Println(e.Ciudad) // Springfield

                La composicion (embedding) promueve la reutilizacion de datos y comportamientos, clave en clean arquitectures

4. INTERFACES Y POLIMORFISMO
    4.1 INTERFAZ
        Es un conjunto de metodos. Define comportamientos sin implementar la logica. Cualquier tipo que provea esos metodos, implementa la interfaz de forma implicita
            Definicion:
                type Describible interface {
                    Describir() string
                }
                // Describible exige que el tipo que la implemente tenga un metodo Describir()
            
            Implementacion implicita:
                No hace falta declarar implements o similar. Si un tipo tiene los metodos requeridos, se convierte automaticamente en implementador de la interfaz
                    type Persona struct {
                        Nombre string
                    }

                    func (p Persona) Describir() string {
                        return "Persona: " + p.Nombre
                    }

                    // Persona implementa Describible sin nada mas:
                    var d Describible = Persona {Nombre: "Ana"}
                    fmt.Println(d.Describir()) // "Persona: Ana"

            Uso de interfaces:
                Permiten desacoplar codigo. Podemos escribir funciones que trabajen con cualquier tipo que implemente la interfaz
                    func Mostrar(d Describible) {
                        fmt.Println(d.Describir())
                    }

                    Mostrar(Persona{"Luis"})
                    // Mostrar funciona con Persona o con cualquier otro tipo que implemente Describir()
            
            Interfaces comunes en la biblioteca estandar:
                error: type error interface { Error() string }
                fmt.Stringer: type Stringer interface { String() string }

                Cualquier tipo con metodo String() string se formatea con fmt
            
            Interface vacia y type assertion:
                Interface vacia "interface{}": puede contener cualquier valor
                    var v interface{}
                    v = 42
                    v = "texto"
                    v = Persona{"Maria"}
                
                Type assertion: para extraer valor concreto de "interface{}"
                    var v interface{} = "hola"
                    s := v.(string)   // s es string, "hola"
                    n, ok := v.(int)  // ok=false, porque v no es int
            
            Slices de interfaces:
                Podes tener colecciones de objetos heterogeneos que implementen la misma interfaz
                    var describibles []Describible
                    describibles = append(describibles, Persona{"Ana"})
                    describibles = append(describibles, OtroTipo{})
                    for _, d := range describibles {
                        fmt.Println(d.Describir())
                    }
            
            Conceptos clave:
                Implicito: solo se necesita tener los metodos para implementarla
                Polimorfismo: multiples tipos pueden implementar la misma interfaz
                Desacoplamiento: el codigo solo depende de la interfaz, no de implementaciones concretas
                Vacia(interface{}): util pero se pierde tipado
